<html>

<head>
    <title>15. Svelte</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="Svelte, JS, JavaScript, script, library, html">
    <link rel="stylesheet" type="text/css" href="../css/main.css">
    <link rel="stylesheet" type="text/css" href="../css/content.css">
    <script src="../javascript/toggleMenu.js"></script>
</head>

<body>
    <div class="navbar">
        <h1 id="title"><a href="../referat.html">15. Svelte</a></h1>
        <div id="menu">
            <img src="../img/menu_icon.png" alt="menu" onclick="toggleMenu()" />
            <div id="menu-content">
                <ul class="no-bullets">
                    <li><a href="#overview">Въведение</a></li>
                    <li><a href="#history">История</a></li>
                    <li><a href="#usage">Къде се използва и за какви цели?</a></li>
                    <li><a href="#create">Настройки и създаване на проект</a></li>
                    <li><a href="#svelte-components">Какво прави Svelte толкова специален?</a></li>
                    <li><a href="#basic-concepts">Основни концепции, функционалности и примери</a></li>
                    <li><a href="#technologies">Свързани технологии</a></li>
                    <li><a href="#why-svelte">Защо Svelte?</a></li>
                </ul>
            </div>
        </div>
    </div>
    </div>

    <div class="generic-content">
        <div class="card" id="overview">
            <div class="topic-header">Въведение <sup>[1][2]</sup></div>
            <hr class="divider" />
            <p>
                Svelte е безплатна за ползване рамка с отворен код за създаване на уеб изгледи. Създадена е от Рич Харис и се поддържа от членовете на основния екип на Svelte. 
                Svelte не е монолитна JavaScript библиотека, която се импортира в приложения. Всъщност Svelte е компалитор за специални HTML шаблони в код, който манипулира директно DOM (Document object model).
                Това значитeлно намаля крайния размер на кода, който се дава на браузъра, и съответно увеличава производителността на клиента.
                Кодът на приложението също се обработва от компилатора, като се вмъкват извиквания за автоматично преизчисляване на данни
                и повторно изобразяване на елементи на потребителския интерфейс, когато данните, от които зависят, се променят.
                Това също така избягва излишните разходи, свързани с междинни представяния по време на изпълнение на приложението, като виртуален DOM - за разлика от други JavaScript библиотеки като React и Vue, 
                които извършват по-голямата част от работата си по време на изпълнение, т.е. в браузъра.
                Самият компилатор е написан на TypeScript под MIT лиценз, а кодът на библиотеката се хоства в GitHub.
            </p>
        </div>
        <div class="card" id="history">
            <div class="topic-header">История <sup>[3][4]</sup></div>
            <hr class="divider" />
            <p>
                А сега малко за това откъде е тръгнало всичко....<br />
                Svelte е създаден от Рич Харис - дизайнер, преквалифицирал се като програмист.
                Харис е бил разочарован от проблемите свързани с производителността на традиционните JavaScript библиотеки като React и Angular - качване на огромно количество ненужен код в браузъра,
                бавно рендериране на UI компоненти заради изкуствени структури като виртуален DOM и други подобни проблеми.
                Той се заема да създаде нов подход, който да реши тези проблеми.
                През 2016 г. Харис пуска първата версия на Svelte, която първоначално е наречена „Ractive.js“.
                Рамката придобива популярност в общността на frontend разработчиците и през 2018 г. Харис ребрандира проекта, както е познат и днес - Svelte.
                <br />
                Версия 2.0 на Svelte бива пусната през 2018 г. В нея се въвеждат редица подобрения в производителността и нови функционалности на библиотеката 
                като реактивни декларации и нова система за обработка на събития в браузъра. 
                <br />
                Svelte 3.0, издаден през 2019 г., е следващата голяма стъпка в развитието на проекта, която въведежда нова архитектура на компилатора и прави рамката още по-лека и ефективна.
                Към новия компилатор е добавена поддръжка за TypeScript, CSS променливи и други модерни уеб технологии.
                От първоначалното си пускане Svelte се радва на значителен брой почитатели сред уеб разработчиците и се използва за създаване на приложения 
                в компании като New York Times, Financial Times и Microsoft. 
                Svelte също е вдъхновява създаването на подобни рамки и библиотеки като Solid.js и Astro, които са изградени на сходни принципи на разработка, свързани с компилатор-ориентиран дизайн.
                <br />
            </p>
        </div>
        <div class="card" id="usage">
            <div class="topic-header">Къде се използва и за какви цели?<sup>[1][2][4]</sup></div>
            <hr class="divider" />
            <p>
                Както вече споменахме - Svelte е удобен за създаване на изгледа на уеб приложения.
                Главните му цели са да предоставя лесен за ползване програмен интерфейс (API), да е минималистичен откъм количество код, което стига до браузъра, 
                и да оптимизира производителността на клиентски приложения.
                Библиотеката позволява на разработчиците да съдават големи приложения чрез специални HTML шаблони (.svetle файлове), които се компилират до минимален JavaScript, който
                се интерпретира от браузъра. Тъй като целта на Svelte е писането на код да остане максимално сходно до писане на стандартен HTML и JavaScript или TypeScript, което прави
                научаването на технология доста по-лесно, отколкото на други подобни библиотеки и рамки като React и Аngular.
            </p>
        </div>
        <div class="card" id="create">
            <div class="topic-header">Настройки и създаване на проект <sup>[1][5][6]</sup></div>
            <hr class="divider"/>
            <p>
                <p>
                    Тъй като Svelte е създаден, за да бъде максимално близък до стандартния JavaScript, съответно и създаването и конфигурирането на проект
                    е силно опростено. Най-лесният (и силно препоръчван) начин за създаване на Svelte проект е следния:
                    <ol>
                        <li>Отваряне на терминала</li>
                        <li>Използване на официалния шаблон за Svelte проекти чрез: 
                            <pre>
                                <code>npx degit sveltejs/template `project-name`</code>
                            </pre>
                        </li>
                        <li>Влизане в директория на проекта:
                            <pre>
                                <code>cd `project-name`</code>
                            </pre>
                        </li>
                        <li>Инсталиране на нужните пакети: 
                            <pre>
                                <code>npm install # or yarn install</code>
                            </pre>
                        </li>
                        <li>След което сте готови да стартирате локален сървър с вашето приложение:
                            <pre>
                                <code>npm run dev # or yarn dev</code>
                            </pre>
                        </li>
                    </ol>
                </p>
                <p>
                    При създаването на Svelte проект се създават следните директории и файлове:
                </p>
                <figure>
                    <img class="image-content" src='../img/project-structure.png' />
                    <figcaption>Генерална струкура на проекта</figcaption>
                </figure>
                <p>    
                    Цялостно струкурата не е твърде различна спрямо при други JavaScript проекти. В папката <code>/public</code> се съдържат всички статични
                    компоненти на приложението като html, css, снимки и други. В <code>/scripts</code> папката се съдържат всякакви помощни скриптове, които не са
                    обвързани пряко с бизнес логиката на приложението - от примера по-горе `setupTypeScript.js` служи, за да направи възможна интерпретацията на 
                    TypeScript от Svelte компилатора. В папката <code>/src</code> се поставят всички компоненти или иначе казано файлове завършващи на .svelte. Също така там честно се намира
                    и файлът, който стартира цялото приложение - обикновено `main.js` или `main.ts`.
                </p>
                <p>
                    Единственият по-важен оставащ въпрос е как всъщност .svelte компонентите се превръщат в код, от който браузъра разбира.
                    Svelte компонентите могат да се импортират като нормално класове и съответно да се инстанцират като такива. В нашия случай искаме да инстанцираме
                    основния компонент на приложението, а именно App.svelte в `main.js`, откъдето, както казахме, ще стартираме цялото приложение.
                    Това ще се случи по следни начин:
                </p>
                <figure>
                    <img class="image-content" src='../img/main_js.png' />
                    <figcaption>Създаване на App обект в main.js</figcaption>
                </figure>
                <p>
                    След като имаме нашият app обект остава един да разберем как този обект се рендерира в браузъра посредством Svelte компилатора. Както забелязваме от структурата на примерния проект,
                    който създадохме по-горе, имаме един доста необичаен файл - `rollup.config.js`. Ако разгледаме кода вътре, ще ни се стори доста странен или дори неразбираем.
                    Ако се вгледаме обаче, ясно можем да разграничим на две части файла. Първата служи за вдигане на приложението ни съответния хост. Като се абстрахираме от ненужните подоброности ясно
                    можем да видим, че стартитра сървър чрез npm:
                </p>
                <figure>
                    <img class="image-content" src='../img/start-server-step.png' />
                    <figcaption>Стартиране на сървър</figcaption>
                </figure>
                <p>
                    Втората част от `rollup.config.js` представлява другата важна стъпка в стартирането на нашето приложение - компилирането на компоненти, статично съдържание и други файлове от Svelte компилатора до 
                    стандартен JavaScript, който може да се интерпретира от браузъра. Отново, ако се абстрахираме от ненужните детайли можем ясно да забележим, че подаваме на компилатора компоненти, които да процесира:
                </p>
                <figure>
                    <img class="image-content" src='../img/compiler-step.png' />
                    <figcaption>Компилиране на Svelte компонентите</figcaption>
                </figure>
                <p>
                Както забелязваме даваме и нашият начален файл - <code>main.js</code> на компилатора, чрез който стартираме приложението си
                </p>
            </p>
        </div>
        <div class="card" id="svelte-components">
            <div class="topic-header">Какво прави Svelte толкова специален?<sup>[1][6][7]</sup></div>
            <hr class="divider" />
            <p>
                Svelte е създаден с идеята за скалирануемост, простота, елегантност и най-важното за реактивност.
                Но какво означава това? В контекста на Svelte и повечето JavaScript технологии за изграждане на уеб приложения
                реактивност е свойството дадено приложението да може лесно да променя състоянието си - както вътрешно, така и за потребителя при дадени условия.
                Тоест искаме да имаме приложение, което и от програматична, и от потребителска гледна точка "реагира" лесно и скалируемо 
                на операции, зададени под някаква форма от потребителя. За тази цел създателите на Svelte са приели по-различна идеология от други библиотеки, като са направили
                максимално опростен и "натурален" процес за създаване реактивни компоненти. Нека направим кратък пример и сравнение за по-добра яснота:
                Ще създадем бутон, който при клик променя стойността си:
            </p>
            <figure>
                <img class="image-content" src="../img/react-counter.png" />
                <figcaption>Бутон на ReactJS</figcaption>
            </figure>
            <figure>
                <img class="image-content" src="../img/svelte-counter.png" />
                <figcaption>Бутон на Svelte</figcaption>
            </figure>
            <figure>
                <video class="video-content" controls>
                    <source src="../img/counter-component.mp4" type="video/mp4" />
                </video>
                <figcaption>Kраен резултат</figcaption>
            </figure>
            <p>
                Привидно двете парчета код изглеждат доста подобни, но при по-задълбочен поглед се забелязва, че кодът от примера с React изглежда доста по-неинтуитивен от този на Svelte.
                В примера със Svelte има доста по-малко "магия" и са нужни сравнително по-малко специализирани знания, за да сме сигурни какво точно прави.
                Също така освен естетическия елемент, който може да е често субективен, всъщност примерът на Svelte заема доста по-малко памет и е по-бърз от примера на React.
                Това се дължи на начина, по който двете библиотеки работят - React поддържа изкуствена in-memory структура, която се нарича виртуален DOM, и служи за транслирането на промени на състоянието
                на даден React компонент в реалния DOM на браузъра. Както можете да се досетите това води до доста скъпи и често ненужни операции. За разлика от това Svelte компилаторът
                елиминира нуждата от всякакви стриктури по време на изпълнение като виртуален DOM, тъй като Svelte компонентите биват транслирани до обикновен JavaScript. Разликата откъм памет между двете
                рамки е толкова голяма, че за едно и също приложение React може да се нуждае от до 40 пъти повече памет спрямо Svelte. Та стигаме до извода, че всъщност Svelte е 
                изключително ефикасен с ресурсите, които използва за разлика от други JavaScript библиотеки за изграждане на уеб приложения.
            </p>
            </p>
        </div>
        <div class="card" id="basic-concepts">
            <div class="topic-header">Основни концепции, функционалности и примери <sup>[1][2][12]</sup></div>
            <hr class="divider" />
            <p>
                <p>
                    След като изследвахме предисторията, причините за създаването, основните предимства и създаването 
                    на проект в Svelte е време да влезем малко по-дълбоко в технологията и да разгледаме по-интересните
                    функционалности, които тя предлага.
                    Главна структурна концепция в Svelte е тази за използване на компоненти.
                    Вместо изкуствено да се разделят технологиите (html, css, javascript) чрез разделяне на логиката и маркъп частта в отделни
                    файлове, в Svelte работата се разделя между слабо зависими помежду си части, наречени компоненти. Те са
                    като блокчета лего, които сглабят една цялостна страница или съответно приложение. Всяко „блокче лего“ е
                    малко преизползваемо парче код.
                </p>
                <h3>Реактивност и компоненти</h3>
                <p>
                    Системата за реактивност на Svelte е основа концепция за начина, по който работи рамката. 
                    При дефиниране на променлива или поле в компонент с ключовата дума "let", 
                    Svelte автоматично проследява тази стойност и генерира код, който актуализира DOM,
                    когато съответната стойност се промени. Това се нарича "реактивно програмиране" и позволява писането на код,
                    който реагира на въвеждането от потребителя и актуализира интерфейса в реално време.

                    Например, да кажем, че искаме да дефинираме променлива "name" по следния начин:
                    <figure>
                        <img class="image-content" src="../img/reactive-variable.png" />
                        <figcaption>Реактивна променлива</figcaption>
                    </figure>
                    <p>След това можем да използваме тази променлива по следния начин в нашия Svelte шаблон:</p>
                    <figure>
                        <img class="image-content" src="../img/reactivity-example.png" />
                        <figcaption>Референция към променливата в компонент</figcaption>
                    </figure>
                    <p>Всеки път, когато променливата "name" се промени, Svelte автоматично ще актуализира DOM, за да отрази новата стойност.</p>
                </p>
                <h3>Логически блокове</h3>
                <p>
                    Често срещан проблем в света на уеб програмирането е рендерирането на различно съдържание спрямо състоянието на приложението или част от него.
                    Тъй като основнато единица мна работа в света на Svelte е компонент е важно да отговорим на въпроса: 
                    "Как мога да показвам различно съдържание спрямо състоянието на някой мой компонент?".
                    Отговорът е сравнително прост, както подсказва заглавието на секцията - чрез логически блокове. Логическите блокове са специален вид маркъп в Svelte шаблон,
                    който позволява изпълняването на различна логика спрямо някакви условия. Можем да разделим логическите блокове на 3 вида:
                </p>
                    
                <h4>1. If-блокове</h4>
                <p>
                    Дефинират се чрез <code>{#if}...{/if}</code>. Тези блокове позволяват да изобразяване на съдържание въз основа на логически израз.
                    Например, можем да използваме if-блок, за да покажем различно съобщение на потребители, които са влезли в приложение ни, и на такива, които не са.
                    <figure>
                        <img class="image-content" src="../img/if-block-example.png" />
                        <figcaption>Пример за if блок</figcaption>
                    </figure>
                </p>
                <h4>2. Each-блокове</h4>
                <p>
                    Друг проблем, който можем да срещнем е визуализацията на масиви. Tоест как бихме могли да изобразим няколко обекта с подобна структура в Svelte - именно чрез each блокове.
                    Те се дефинират чрез <code>{#each}...{/each}</code>. Те позволяват итерирането през всеки елемент на масив и визуализирането на съответние елемент.
                    Например нека имаме списък от продукти, които получаваме от някое API и искаме да ги изобразим в браузъра като неподреден списък.
                    Това би се случило по следния начин:
                    <figure>
                        <img class="image-content" src="../img/each-block-example.png" />
                        <figcaption>Пример за each-блок</figcaption>
                    </figure>
                </p>
                <h4>3. Await-блокове</h4>
                <p>
                    Този тип блокове е не толкова прост, колкото останалите. Нуждата за този вид блокове се поражда от асинхронните заявки в JavaScript,
                    които са твърде често явление, за да бъдат игнорирани. Await-блоковете се дефинират чрез <code>{#await}...{:then}...{:catch}</code> - доста сходно
                    на съответните ключови думи в JavaScript. Нека си представим, че правим заявка към някакъв сървър, от който искаме да получим някаква информация.
                    Съответно искаме да визуализираме различни компоненти на потребителя спрямо състоянието на заявката - в процес на изпълнение, успешно изпълнена,
                    неуспешно изпълнена. Това ще се случи, като подадем на await-блока promise, за чието състояние да следи. Накрая кодът ни би изглеждал по подобен начин:
                    <figure>
                        <img class="image-content" src="../img/await-block-example.png" />
                        <figcaption>Пример за await-блок</figcaption>
                    </figure>
                </p>
                    
                <h3>Събития и вход от потребителя</h3>
                <p>
                    Svelte позволява слушането на събития от потребителя в компоненти чрез специални директиви за различните събития.
                    Например можем чрез директиви като <code>on:click</code>, <code>on:input</code>, <code>on:submit</code>, <code>on:mouseover</code> и други да изпълняваме дадена логика.
                    Вече онагледихме ползването на <code>on:click</code> чрез примера с брояча от по-горе. Нещо обаче, което не се забелязва в горния пример е това,
                    че всъщност подава на функциите, подадени на съответната директива, обект от тип събитие, което съдържа допълнителна информация за събитието като вид,
                    целеви елемент и друга специфична информация. Нека направим малък компонент, който ще покаже полезнотата от подобна функционалност. Нека си представим,
                    че при въвеждане на текст в поле от потребителя, бихме искали да вземем стойността, която е въвел и да направим нещо с нея - било то да я валидираме, визуализираме или нещо друго.
                    За простота нека в нашия пример просто показваме въведеното от потребителя:
                </p> 
                <figure>
                    <img class="image-content" src="../img/event-example.png" />
                    <figcaption>Пример за използване на събитие</figcaption>
                </figure>
                <figure>
                    <video class="video-content" controls>
                        <source src="../img/event-example-result.mp4" type="video/mp4" />
                    </video>
                    <figcaption>Kраен резултат</figcaption>
                </figure>
                <p>
                    Друга интересна функционалност, която Svelte предлага е създаването на събития от компоненти, а не от потребителя.
                    Това се случва чрез функцията <code>createEventDispatcher()</code>, която връща функция, служеща за извествяването на друг компонент за събитието.
                    На пръв поглед изглежда странно, но всъщност е доста полезен инструмент, тъй като позволява пренасяне на данни от дете към родителски компонент.
                    Нека илюстрираме това със следния пример. Искаме да направим бутон, който при натискане, ще показва поздрав за потребителя. За простота ще
                    приемем, че потребителят ни се казва Иван. Ще имаме два компонента:
                    <figure>
                        <img class="image-content" src="../img/button-dispatch-example.png" />
                        <figcaption>Button.svelte</figcaption>
                    </figure>
                    <figure>
                        <img class="image-content" src="../img/app-dispatch-example.png" />
                        <figcaption>App.svelte</figcaption>
                    </figure>
                    <figure>
                        <video class="video-content" controls>
                            <source src="../img/dispatch-result.mp4" type="video/mp4" />
                        </video>
                        <figcaption>Kраен резултат</figcaption>
                    </figure>
                </p> 
                <h3>Функции, свързани с жизнения цикъл на компонент</h3>
                <p>
                    Всеки Svelte компонент има жизнен цикъл, който започва със създаването на компонента и приключва с премахването му от DOM
                    или неговото унищожаване. През различните моменти от съществуването на компонента може да се нуждаем от специфична функционалност,
                    която да се изпълнява точно в даден момент - веднага при създаване, при унищожаване и т.н. Основните функции са няколко:
                    <h4>onMount()</h4>
                    <p>
                        Тази функция служи за изпълняването на логика при създаването на компонента.
                        Често се ползва за изпълняването на асинхронни операции преди визуализирането на компонента.
                        Пример за полезността на такъв вид функция е да кажем секцията с публикации в някоя социална мрежа (feed).
                        Ако имаме такъв компонент, бихме искали той да направи заявка към сървъра за всички постове точно при създаването си, за да ги визуализира.
                    </p>
                    <h4>onDestory()</h4>
                    <p>
                        onDestory() e противоположността на onMount() - служи за изпълняването на логика при унищожаванете на компонента.
                        В практиката намира сравнително по-малко приложение от onMount(). Предимно се използва за изчистване или промяна на 
                        състояние (например извикване на функции като clearInterval() или clearTimeout()). 
                    </p>
                    <h4>beforeUpdate() and afterUpdate()</h4>
                    <p>
                        Както имената им подсказват - служат за изпълняване на логика преди или след промяна в компонент. 
                        Примерен случай за употреба е,когато искаме да изпълним страничен ефект при промяна на състоянието 
                        на съответния компонент (да променим динамично стила на компонента или да променим състоянието на друг компонент).
                    </p>
                </p>
                <h3>Преходи и анимации</h3>
                <p>
                    Както вече казахме, голяма част от философията на Svelte e да е реактивен и да позволява създаването на
                    приятни за ползване уеб приложения. За целта в технологията е добавена директива, която позволява лесното добавяне на преходи 
                    към различните компоненти, което да подобри преживяването на потребителите. Това се случва чрез използването на директивата
                    transition и съответния тип преход, която искаме да добавим - <code>transition:(type)</code>. Примери за типове преходи са избеляване (fade),
                    летене (fly), плъзване (slide) и други. Ще илюстрираме ефективността на този инструмент с пример, в който ще "избелеем" изображение при 
                    натискане на бутон:
                </p>
                <figure>
                    <img class="image-content" src="../img/fade-example.png" />
                    <figcaption>Пример за използване на събитие</figcaption>
                </figure>
                <figure>
                    <video class="video-content" controls>
                        <source src="../img/fade-example-result.mp4" type="video/mp4" />
                    </video>
                    <figcaption>Kраен резултат</figcaption>
                </figure>
                <p>Други интересни ефекти, които Svelte поддържа, са анимации на компоненти чрез директивата <code>animate</code> и използването на действия (actions)</p>
        </div>
        <div class="card" id="technologies">
            <div class="topic-header">Свързани технологии <sup>[9][10][11]</sup></div>
            <hr class="divider" />
            <p>
                Нека споменем макар и с няколко думи някои технологии, които изключително често се използват в
                практиката заедно с React.
                <ol>
                    <li>
                        <em>SvelteKit</em> - рамка за изграждане на уеб приложения със Svelte. Предоставя цялостно решение за разработване, 
                        изграждане и внедряване на приложения на Svelte и включва наготово функционалности като изобразяване от страна на сървъра (server-side rendering), 
                        и генериране на статични сайтове и др. Еквивалентно е на Next.js в React и Nuxt във Vue.
                    </li>
                    <li>
                        <em>Vite</em> - инструмент за изграждане (build tool) и сървър за разработка, който е специално проектиран за съвременни работни процеси за уеб разработка.
                        Основната цел на Vite е да осигури бързa, лекa и гъвкавa разработка. Това се постига чрез използване на модерни функционалности на браузъра като ES модули и бързо презареждане на модули (HMR),
                         което позволява почти мигновена обратна връзка на промените, направени по време на разработката. Подобни инструменти са Parcel и WebPack.
                    </li>
                    <li>
                        <em>Semantic</em> - набор от готови стилизирани компоненти за подобряване на дизайна на уебсайтове. Подобни инструменти са Material и BootStrap.
                    </li> 
                </ol>
            </p>
        </div>
        <div class="card" id="why-svelte">
            <div class="topic-header">Защо Svelte? <sup>[5][8][9]</sup></div>
            <hr class="divider" />
            <p>
                <ol>
                    <li>Прост и лесен за учене</li>
                    <li>Преизползваемост на компонентите</li>
                    <li>Бързина и ефикасност на разработка и на приложението</li>
                    <li>Поддържа повече функционалности за интерактивен интерфейс</li>
                    <li>Харесван от общността</li>
                    <li>Бързо набира популярност</li>
                </ol>
            </p>
        </div>

        <div class="card" id="sources">
            <div class="topic-header">Използвани източници:</div>
            <hr class="divider" />
            <div>
                <div class="source">
                    <a href="https://svelte.dev/">[1]
                        https://svelte.dev/</a>
                    Официална документация на Svelte, последно посетен на 31.03.2023
                </div>
                <div class="source">
                    <a
                        href="https://www.zyxware.com/article/what-is-svelte-why-is-it-so-popular">[2]
                        https://www.zyxware.com/article/what-is-svelte-why-is-it-so-popular
                    </a> Написана от Sani Phillip на 04.01.2023, последно посетен на 31.03.2023
                </div>
                <div class="source">
                    <a href="https://www.offerzen.com/community/svelte-origins-documentary">[3]
                        https://www.offerzen.com/community/svelte-origins-documentary</a>
                        Създаден от Dewald Brand, последно посетен на 31.03.2023
                </div>
                <div class="source">
                    <a href="https://thenewstack.io/svelte-and-the-future-of-front-end-development/">[4]
                        https://thenewstack.io/svelte-and-the-future-of-front-end-development/</a>
                    Написано от Joab Jackson на 11.05.2022, последно посетен на 31.03.2023
                </div>
                <div class="source">
                    <a href="https://medium.com/geekculture/why-web-developers-need-to-try-svelte-a389cb63ecd6">[5]
                        https://medium.com/geekculture/why-web-developers-need-to-try-svelte-a389cb63ecd6</a>
                    Написано от Aidan Tilgner на 23.01.2022, последно посетен на 31.03.2023
                </div>
                <div class="source">
                    <a href="https://bugfender.com/blog/create-your-first-svelte-app/">[6]
                        https://bugfender.com/blog/create-your-first-svelte-app/</a>
                    Написано на 28.08.2021 oт Tapas Adhikary, последно посетен на 01.04.2023
                </div>
                <div class="source">
                    <a href="https://refine.dev/blog/svelte-vs-react/">[7] https://refine.dev/blog/svelte-vs-react/</a>
                    Написано oт Chidume Nnamdi, последно посетен на 01.04.2023
                </div>
                <div class="source">
                    <a href="https://survey.stackoverflow.co/2022/#most-loved-dreaded-and-wanted-webframe-love-dread">
                        [8] https://survey.stackoverflow.co/2022/#most-loved-dreaded-and-wanted-webframe-love-dread</a>
                    Годишно проучване на Stackoverflow за 2022, последно посетен на 01.04.2023
                </div>
                <div class="source">
                    <a href="https://naturaily.com/blog/why-svelte-is-next-big-thing-javascript-development">
                        [9] https://naturaily.com/blog/why-svelte-is-next-big-thing-javascript-development
                    </a>
                        Написано на 22.03.2022 oт Beata Twardowska, последно посетен на 01.04.2023
                </div>
                <div class="source">
                    <a href="https://kit.svelte.dev/docs/introduction">
                        [10] https://kit.svelte.dev/docs/introduction
                    </a>
                        Част от официалната документация на SvelteKit, последно посетен на 06.04.2023
                </div>
                <div class="source">
                    <a href="https://www.gpmd.co.uk/blog/what-is-vite-and-why-do-you-need-it">
                        [11] https://www.gpmd.co.uk/blog/what-is-vite-and-why-do-you-need-it
                    </a>
                        Написано на 24.05.2022 oт Tom Early, последно посетен на 06.04.2023
                </div>
                <div class="source">
                    <a href="https://svelte.dev/tutorial/basics">
                        [12] https://svelte.dev/tutorial/basics
                    </a>
                        Официална документация и демо на основни функционалности на Svelte. Поддържа  от екипа, разработващ Svelte, последно посетен на 09.04.2023.
                </div>
            </div>
        </div>
    </div>
</body>
</html>
